#!/bin/bash

set -eu

DOCKERFILES=${DOCKERFILES:-$HOME/dockerfiles}
DOCKER_BUILD_OPT=""

if [[ -f "$HOME/.docker-depotrc" ]]; then
  . "$HOME/.docker-depotrc"
fi

VERSION=0.1.0
HUMAN_READABLE=1
TRUNC=1
QUIET=""

FILTER_FROM="*"
FILTER_FROM_ID=""
FILTER_ISOLATED=""
FILTER_NONE=""

usage() {
cat <<DATA
Usage: docker-depot COMMAND [OPTION]
       docker-depot [ -h | --help | -v | --version ]

COMMAND:
  list    List information
  build   Build docker image

Run 'docker-depot COMMAND --help' for more information on a command.
DATA
exit 0
}

build_help() {
cat <<DATA
Usage: docker-depot build [OPTION] [IMAGE...] -- [BUILD_OPTION...]
  Build docker image

OPTION:
  -h, --help              Print usage

OPTION (filter):
  --from=FROM_IMAGE
  --from-id[=FROM_ID]
  --isolated
  --none


IMAGE:
  Docker image names. Supports glob pattern.
  e.g. name, name:tag, "*", "*:*"

BUILD_OPTION:
  Docker build option.

DATA
exit 0
}

list_help() {
cat <<DATA
Usage: docker-depot list [OPTION] [IMAGE...]
  Build docker image

IMAGE:
  Docker image names. Supports glob pattern.
  e.g. name, name:tag, "*", "*:*"

OPTION:
  -m, --machine-readable
      --no-trunc          Don't truncate output
  -q, --quiet             Only show numeric IDs
  -i, --image             Only show IMAGE
  -h, --help              Print usage

OPTION (filter):
  --from=FROM_IMAGE
  --from-id[=FROM_ID]
  --isolated
  --none

DATA
exit 0
}

abort() {
  echo "$1" >&2
  exit 1
}

parse_filter_option() {
  case $1 in
    --from | --from=*)
      local from=${1:7}
      [[ $from ]] || abort "--from not specified FROM_IMAGE"
      [[ $from = *:* ]] && FILTER_FROM=$from || FILTER_FROM="$from:latest"
      ;;
    --from-id | --from-id=*)
      local from_id=${1:10}
      if [[ $from_id ]]; then
        FILTER_FROM_ID="$from_id"
      else
        FILTER_FROM_ID="??" # To match except 0.
      fi
      ;;
    --isolated) FILTER_ISOLATED=1 ;;
    --none) FILTER_NONE=1 ;;
    *) return 1
  esac
  return 0
}

build() {
  local names=() images=()

  while (( $# > 0 )); do
    if ! parse_filter_option "$1"; then
      case $1 in
        --help) build_help ;;
        --) break ;;
        -*) abort "No such option" ;;
        *) break
      esac
    fi
    shift
  done

  while (( $# > 0 )); do
    case $1 in
      --) shift; break ;;
      -*) abort "Invalid image name" ;;
      *) names[${#names[@]}]=$1 ;;
    esac
    shift
  done

  if ! (( ${#names[@]} )); then
    if [[ $FILTER_FROM != "*" || $FILTER_FROM_ID || $FILTER_ISOLATED || $FILTER_NONE ]]; then
      names=("*:*")
    else
      abort "build is required filter options or name"
    fi
  fi

  while IFS="|" read -r image _; do
    images[${#images[@]}]=$image
  done < <(get_list "${names[@]}")

  if (( ${#images[@]} )); then
    for image in "${images[@]}"; do
      local name=${image%:*}
      local tag=${image#*:}
      cd "$DOCKERFILES/$name/$tag"
      # shellcheck disable=SC2086
      docker build -t "$name:$tag" ${DOCKER_BUILD_OPT:-} "$@" ./
    done
  fi
}

list() {
  while (( $# > 0 )); do
    if ! parse_filter_option "$1"; then
      case $1 in
        -m | --machine-readable) HUMAN_READABLE="" ;;
        -q | --quiet) QUIET="id" ;;
        -i | --image) QUIET="image" ;;
        --no-trunc) TRUNC="" ;;
        --help) list_help ;;
        -*) abort "No such option" ;;
        *) break
      esac
    fi
    shift
  done

  local names=()
  while (( $# > 0 )); do
    case $1 in
      -*) abort "Invalid image name" ;;
      *) names[${#names[@]}]=$1 ;;
    esac
    shift
  done

  if ! (( ${#names[@]} )); then
    names=("*:*")
  fi

  (
    if [[ $HUMAN_READABLE && $QUIET = "" ]]; then
      echo "IMAGE|IMAGE ID|FROM IMAGE|FROM ID|CREATED|PILE SIZE|VIRTUAL SIZE"
    fi
    while IFS="|" read -r image id from from_id created psize vsize; do
      local data
      case $QUIET in
        id) data=("$(disp_id "$id")") ;;
        image) data=($image) ;;
        *)
          data=(
            "$image"
            "$(disp_id "$id")"
            "$from"
            "$(disp_id "$from_id")"
            "$(disp_date "$created")"
            "$(disp_size "$psize")"
            "$(disp_size "$vsize")"
          )
      esac
      (IFS='|'; echo "${data[*]}")
    done < <(get_list "${names[@]}")
  ) | column -t -s'|'
}

disp_id() {
  if [[ ! $1 ]]; then
    echo "<none>"
  elif [[ $1 = 0 ]]; then
    echo "<isolated>"
  else
    if [[ $TRUNC ]]; then
      echo "${1:0:12}"
    else
      echo "$1"
    fi
  fi
}

disp_date() {
  if [[ ! $1 ]]; then
    echo "<none>"
  elif [[ $HUMAN_READABLE ]]; then
    date -d "$1" +"%Y-%m-%d %H:%M:%S"
  else
    echo "${1%.*}Z"
  fi
}

disp_size() {
  if [[ ! $1 ]]; then
    echo "<none>"
  elif [[ $HUMAN_READABLE ]]; then
    if (( $1 > 1000000000)); then
      echo "$(bc < <(echo "scale=2; $1 / 1000000000")) GB"
    elif (( $1 > 1000000)); then
      echo "$(bc < <(echo "scale=2; $1 / 1000000")) MB"
    elif (( $1 > 1000)); then
      echo "$(bc < <(echo "scale=2; $1 / 1000")) KB"
    else
      echo "$1 B"
    fi
  else
    echo "$1"
  fi
}

find_defined_images() {
  local path name tag

  if [[ $# = 0 ]]; then
    find_defined_images "*:*"
    return 0
  fi

  while IFS= read -r line; do
    path=${line:2}
    path=${path%/*}
    name=${path%/*}
    tag=${path##*/}

    for image in "$@"; do
      [[ $image = *:* ]] || image="$image:latest"

      # shellcheck disable=SC2053
      if [[ "$name:$tag" = $image ]]; then
        echo "$name:$tag"
        break
      fi
    done
  done < <(
    cd "$DOCKERFILES"
    find -L ./ -mindepth 3 -name Dockerfile | sort
  )
}

get_list() {
  declare -A hierarchies
  local id data
  local format='{{.Id}} {{.Parent}}:{{.VirtualSize | printf "%.0f"}}'
  while read -r id data; do
    hierarchies[$id]=$data
  done < <(docker images -aq | docker_inspect "$format")

  declare -A name_id_map
  local image id
  while read -r image id; do
    name_id_map[$image]=$id
  done < <(get_tagged_images | get_image_info "{{.Id}}")

  local format='{{.Id}} {{.Parent}} {{.Created}} {{.VirtualSize | printf "%.0f"}}'
  local image id parent_id created vsize psize from from_id from_data from_size
  while read -r image id parent_id created vsize; do
    from=$(get_from_image "$image")

    if [[ $parent_id ]]; then
      while [[ $parent_id ]]; do
        [[ ${name_id_map[$from]:-} = "$parent_id" ]] && break
        parent_data=${hierarchies[$parent_id]}
        parent_id=${parent_data%%:*}
      done
      if [[ $parent_id ]]; then
        from_id=$parent_id
        from_data=${hierarchies[$parent_id]}
        from_size=${from_data##*:}
      else
        from_id=0
        from_size=0
      fi
      psize=$((vsize - from_size))
    else
      from_id=""
      from_size=""
      psize=""
    fi

    local disp=""
    # shellcheck disable=SC2053
    if [[ $from = $FILTER_FROM ]]; then
      if [[ $FILTER_FROM_ID || $FILTER_NONE || $FILTER_ISOLATED ]]; then
        [[ $from_id = $FILTER_FROM_ID* && $FILTER_FROM_ID ]] && disp=1
        [[ $from_id = "" && $FILTER_NONE ]] && disp=1
        [[ $from_id = 0 && $FILTER_ISOLATED ]] && disp=1
      else
        disp=1
      fi
    fi

    if [[ $disp ]]; then
      echo "$image|$id|$from|$from_id|$created|$psize|$vsize"
    fi
  done < <(find_defined_images "$@" | get_image_info "$format")
}

get_from_image() {
  local file="$DOCKERFILES/${1/:/\/}/Dockerfile"
  local line from

  line=$(grep "FROM " "$file" | tail -n 1)
  from=${line##* }
  [[ $from = *:* ]] && echo "$from" || echo "$from:latest"
}

get_image_info() {
  local format=$1
  local images name named_images inspect="" info
  shift

  images=$(uniq | sort)
  [[ $images ]] || return 0

  named_images=$(join <(echo "$images") <(get_tagged_images | sort))
  if [[ $named_images ]]; then
    inspect=$(docker_inspect "$format" <<< $named_images)
  fi
  info=$(paste <(echo "$named_images") <(echo "$inspect"))
  join  -a 1 -1 1 -2 1 -o 0 2.{2..10} <(echo "$images") <(echo "$info")
}

get_tagged_images() {
  local name tag id
  while read -r name tag id _; do
    [[ $name = "<none>" ]] || echo "$name:$tag"
  done < <(docker images | tail -n +2)
}

docker_inspect() {
  local array=($(cat))
  docker inspect -f "$1" "${array[@]}"
}


[[ $# = 0 ]] && usage

case $1 in
  -h | --help) usage ;;
  -v | --version) echo $VERSION; exit 0 ;;
  build) build "${@:2}" ;;
  list) list "${@:2}" ;;
  *) abort "No such command"
esac
